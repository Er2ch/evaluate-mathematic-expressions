# Калькулятор. Выполнение математического выражения.

> DEV ВЕТКА!!! ЭТО МОЖЕТ БЫТЬ **НЕСТАБИЛЬНО**

## Описание возможностей:
+ 7 операторов:

    - сумма "+"
    - разность "-"
    - частное ":"
    - произведение "*"
    - деление по модулю "%"
    - деление нацело "/"
    - возведение в степень "^"

+ Скобочные объеденения: "()"
+ Числа с плавающей точкой (запятой): "1.2"
<!--
+ Константы:
    - число Эйлера "e"
    - число пи "pi"
+ Возможность задавать свои константы используя флаг "-d": "-dvarname=value"
-->

## Сборка

Собрать код можно с помощью утилиты make

Для компиляции в режиме отладки (дебага), команда будет вида:
`make DEBUG=1 <цель>`

Все цели указаны ниже:

+ all - редирект в build
+ build - собирает calc
+ lib - собирает libcalc.a
+ calc - зависит от lib и зависимостей REPL
+ libcalc.a - зависит от базы, на которой можно написать свой API
+ clean - чистка проекта от собранных файлов
+ debug - clean, build **с флагом DEBUG=1**, а затем исполнение через gdb
+ run - сборка и исполнение файла

## Части программы

### Лексер
Анализатор входной строки. Сразу проверяет выражение на корректность, проверяя последовательность из 2 токенов: текущая и прошлая, при не разрешенной последовательности будет происходить ошибка "Unexpected token 'токен' at 'позиция'". 

Каждмому символу присваивает тип, получается токен. Лексер возвращает массив токенов.

Всего используется 5 видов токенов:
+ число: 0-9
+ операторы: "+", "-", "*", ":", "/", "%", "^"
+ десятичный разделитель: "."
+ скобки: "(" и ")"
+ текст: a-z

### Парсер
Синтаксический анализатор. Составляет так называемое дерево парсинга. Выражение делится на 2 части, пока не останется под-выражений с операторами. Основная идея в том, что с конца строки ищется оператор, с наименьшим приоритетом.

### VM
Часть, отвечающая за исполнение выражения. Используется алгоритм обхода дерева.
Принцип простой: обработв текущую ветку, функция вызывает сама себя для разветвлений.
